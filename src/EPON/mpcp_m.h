//
// Generated file, do not edit! Created by nedtool 5.0 from src/EPON/mpcp.msg.
//

#ifndef __MPCP_M_H
#define __MPCP_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0500
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



/**
 * Enum generated from <tt>src/EPON/mpcp.msg:18</tt> by nedtool.
 * <pre>
 * enum FrameTag
 * {
 * 
 *     TagNormal = 0;
 *     TagDebug = 1;
 *     TagFront = 2;
 *     TagBack = 3;
 *     TagFrontAndBack = 4;
 * }
 * </pre>
 */
enum FrameTag {
    TagNormal = 0,
    TagDebug = 1,
    TagFront = 2,
    TagBack = 3,
    TagFrontAndBack = 4
};

/**
 * Enum generated from <tt>src/EPON/mpcp.msg:27</tt> by nedtool.
 * <pre>
 * enum Response
 * {
 * 
 *     NOSIGNAL = -1;
 *     NONE = 0;
 *     ACK = 1;
 *     NACK = 2;
 *     CS = 3;
 *     DS = 4;
 * }
 * </pre>
 */
enum Response {
    NOSIGNAL = -1,
    NONE = 0,
    ACK = 1,
    NACK = 2,
    CS = 3,
    DS = 4
};

/**
 * Class generated from <tt>src/EPON/mpcp.msg:37</tt> by nedtool.
 * <pre>
 * packet Frame
 * {
 *     int64_t DST;
 *     int64_t SRC;
 *     simtime_t rxTime;
 *     simtime_t txTime;
 * 
 *     //debug
 *     int tag @enum(FrameTag) = TagNormal;
 * }
 * </pre>
 */
class Frame : public ::omnetpp::cPacket
{
  protected:
    int64_t DST;
    int64_t SRC;
    ::omnetpp::simtime_t rxTime;
    ::omnetpp::simtime_t txTime;
    int tag;

  private:
    void copy(const Frame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Frame&);

  public:
    Frame(const char *name=nullptr, int kind=0);
    Frame(const Frame& other);
    virtual ~Frame();
    Frame& operator=(const Frame& other);
    virtual Frame *dup() const {return new Frame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int64_t getDST() const;
    virtual void setDST(int64_t DST);
    virtual int64_t getSRC() const;
    virtual void setSRC(int64_t SRC);
    virtual ::omnetpp::simtime_t getRxTime() const;
    virtual void setRxTime(::omnetpp::simtime_t rxTime);
    virtual ::omnetpp::simtime_t getTxTime() const;
    virtual void setTxTime(::omnetpp::simtime_t txTime);
    virtual int getTag() const;
    virtual void setTag(int tag);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Frame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Frame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:48</tt> by nedtool.
 * <pre>
 * packet DataFrame extends Frame
 * {
 *     //delay performance analysis
 *     bool vacation = false;
 *     simtime_t residualTime = 0;
 *     simtime_t queueTime = 0;
 * 
 *     //
 *     bool forwarded = false;
 *     simtime_t s1Delay = 0;
 *     simtime_t burstTime = 0;
 * 
 * 	//simtime_t AFwdDelay = 0;
 * 	//simtime_t AS1Delay = 0;
 * 	//simtime_t AS2Delay = 0;
 * 	//simtime_t ABurstTime = 0;
 * }
 * </pre>
 */
class DataFrame : public ::Frame
{
  protected:
    bool vacation;
    ::omnetpp::simtime_t residualTime;
    ::omnetpp::simtime_t queueTime;
    bool forwarded;
    ::omnetpp::simtime_t s1Delay;
    ::omnetpp::simtime_t burstTime;

  private:
    void copy(const DataFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DataFrame&);

  public:
    DataFrame(const char *name=nullptr, int kind=0);
    DataFrame(const DataFrame& other);
    virtual ~DataFrame();
    DataFrame& operator=(const DataFrame& other);
    virtual DataFrame *dup() const {return new DataFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual bool getVacation() const;
    virtual void setVacation(bool vacation);
    virtual ::omnetpp::simtime_t getResidualTime() const;
    virtual void setResidualTime(::omnetpp::simtime_t residualTime);
    virtual ::omnetpp::simtime_t getQueueTime() const;
    virtual void setQueueTime(::omnetpp::simtime_t queueTime);
    virtual bool getForwarded() const;
    virtual void setForwarded(bool forwarded);
    virtual ::omnetpp::simtime_t getS1Delay() const;
    virtual void setS1Delay(::omnetpp::simtime_t s1Delay);
    virtual ::omnetpp::simtime_t getBurstTime() const;
    virtual void setBurstTime(::omnetpp::simtime_t burstTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DataFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DataFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:66</tt> by nedtool.
 * <pre>
 * packet MPCPGate extends Frame
 * {
 *     simtime_t startTime;
 *     simtime_t length;
 * }
 * </pre>
 */
class MPCPGate : public ::Frame
{
  protected:
    ::omnetpp::simtime_t startTime;
    ::omnetpp::simtime_t length;

  private:
    void copy(const MPCPGate& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MPCPGate&);

  public:
    MPCPGate(const char *name=nullptr, int kind=0);
    MPCPGate(const MPCPGate& other);
    virtual ~MPCPGate();
    MPCPGate& operator=(const MPCPGate& other);
    virtual MPCPGate *dup() const {return new MPCPGate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual ::omnetpp::simtime_t getStartTime() const;
    virtual void setStartTime(::omnetpp::simtime_t startTime);
    virtual ::omnetpp::simtime_t getLength() const;
    virtual void setLength(::omnetpp::simtime_t length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MPCPGate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MPCPGate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:72</tt> by nedtool.
 * <pre>
 * packet MPCPReport extends Frame
 * {
 *     int requiredBandwidth;
 *     simtime_t startTime;
 * }
 * </pre>
 */
class MPCPReport : public ::Frame
{
  protected:
    int requiredBandwidth;
    ::omnetpp::simtime_t startTime;

  private:
    void copy(const MPCPReport& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MPCPReport&);

  public:
    MPCPReport(const char *name=nullptr, int kind=0);
    MPCPReport(const MPCPReport& other);
    virtual ~MPCPReport();
    MPCPReport& operator=(const MPCPReport& other);
    virtual MPCPReport *dup() const {return new MPCPReport(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getRequiredBandwidth() const;
    virtual void setRequiredBandwidth(int requiredBandwidth);
    virtual ::omnetpp::simtime_t getStartTime() const;
    virtual void setStartTime(::omnetpp::simtime_t startTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MPCPReport& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MPCPReport& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:78</tt> by nedtool.
 * <pre>
 * packet SLAGate extends MPCPGate
 * {
 *     //simtime_t pollingCycleTime;
 *     int signal @enum(Response);
 *     simtime_t sleepTime;
 *     simtime_t wakeUpTime;
 * }
 * </pre>
 */
class SLAGate : public ::MPCPGate
{
  protected:
    int signal;
    ::omnetpp::simtime_t sleepTime;
    ::omnetpp::simtime_t wakeUpTime;

  private:
    void copy(const SLAGate& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SLAGate&);

  public:
    SLAGate(const char *name=nullptr, int kind=0);
    SLAGate(const SLAGate& other);
    virtual ~SLAGate();
    SLAGate& operator=(const SLAGate& other);
    virtual SLAGate *dup() const {return new SLAGate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getSignal() const;
    virtual void setSignal(int signal);
    virtual ::omnetpp::simtime_t getSleepTime() const;
    virtual void setSleepTime(::omnetpp::simtime_t sleepTime);
    virtual ::omnetpp::simtime_t getWakeUpTime() const;
    virtual void setWakeUpTime(::omnetpp::simtime_t wakeUpTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SLAGate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SLAGate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:86</tt> by nedtool.
 * <pre>
 * packet SLAReport extends MPCPReport
 * {
 *     int signal @enum(Response);
 *     //simtime_t nextFwdTime = 0;
 * }
 * </pre>
 */
class SLAReport : public ::MPCPReport
{
  protected:
    int signal;

  private:
    void copy(const SLAReport& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SLAReport&);

  public:
    SLAReport(const char *name=nullptr, int kind=0);
    SLAReport(const SLAReport& other);
    virtual ~SLAReport();
    SLAReport& operator=(const SLAReport& other);
    virtual SLAReport *dup() const {return new SLAReport(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getSignal() const;
    virtual void setSignal(int signal);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SLAReport& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SLAReport& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:92</tt> by nedtool.
 * <pre>
 * packet CSLAGate extends Frame
 * {
 *     //simtime_t pollingCycleTime;
 *     int Grant1TransceiverMode @enum(Response);
 *     simtime_t Grant1StartTime;
 *     simtime_t Grant1Length;
 *     simtime_t Grant2StartTime;
 *     simtime_t Grant2Length;
 * }
 * </pre>
 */
class CSLAGate : public ::Frame
{
  protected:
    int Grant1TransceiverMode;
    ::omnetpp::simtime_t Grant1StartTime;
    ::omnetpp::simtime_t Grant1Length;
    ::omnetpp::simtime_t Grant2StartTime;
    ::omnetpp::simtime_t Grant2Length;

  private:
    void copy(const CSLAGate& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CSLAGate&);

  public:
    CSLAGate(const char *name=nullptr, int kind=0);
    CSLAGate(const CSLAGate& other);
    virtual ~CSLAGate();
    CSLAGate& operator=(const CSLAGate& other);
    virtual CSLAGate *dup() const {return new CSLAGate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getGrant1TransceiverMode() const;
    virtual void setGrant1TransceiverMode(int Grant1TransceiverMode);
    virtual ::omnetpp::simtime_t getGrant1StartTime() const;
    virtual void setGrant1StartTime(::omnetpp::simtime_t Grant1StartTime);
    virtual ::omnetpp::simtime_t getGrant1Length() const;
    virtual void setGrant1Length(::omnetpp::simtime_t Grant1Length);
    virtual ::omnetpp::simtime_t getGrant2StartTime() const;
    virtual void setGrant2StartTime(::omnetpp::simtime_t Grant2StartTime);
    virtual ::omnetpp::simtime_t getGrant2Length() const;
    virtual void setGrant2Length(::omnetpp::simtime_t Grant2Length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CSLAGate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CSLAGate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:102</tt> by nedtool.
 * <pre>
 * packet CSLAReport extends Frame
 * {
 *     int Request1Length;
 *     //simtime_t NextFwdTime;
 * }
 * </pre>
 */
class CSLAReport : public ::Frame
{
  protected:
    int Request1Length;

  private:
    void copy(const CSLAReport& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CSLAReport&);

  public:
    CSLAReport(const char *name=nullptr, int kind=0);
    CSLAReport(const CSLAReport& other);
    virtual ~CSLAReport();
    CSLAReport& operator=(const CSLAReport& other);
    virtual CSLAReport *dup() const {return new CSLAReport(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getRequest1Length() const;
    virtual void setRequest1Length(int Request1Length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CSLAReport& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CSLAReport& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:108</tt> by nedtool.
 * <pre>
 * packet GBAGate extends MPCPGate
 * {
 *     simtime_t ONUSleepTime;
 * }
 * </pre>
 */
class GBAGate : public ::MPCPGate
{
  protected:
    ::omnetpp::simtime_t ONUSleepTime;

  private:
    void copy(const GBAGate& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GBAGate&);

  public:
    GBAGate(const char *name=nullptr, int kind=0);
    GBAGate(const GBAGate& other);
    virtual ~GBAGate();
    GBAGate& operator=(const GBAGate& other);
    virtual GBAGate *dup() const {return new GBAGate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual ::omnetpp::simtime_t getONUSleepTime() const;
    virtual void setONUSleepTime(::omnetpp::simtime_t ONUSleepTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GBAGate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GBAGate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/EPON/mpcp.msg:113</tt> by nedtool.
 * <pre>
 * packet GBAReport extends MPCPReport
 * {
 * }
 * </pre>
 */
class GBAReport : public ::MPCPReport
{
  protected:

  private:
    void copy(const GBAReport& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GBAReport&);

  public:
    GBAReport(const char *name=nullptr, int kind=0);
    GBAReport(const GBAReport& other);
    virtual ~GBAReport();
    GBAReport& operator=(const GBAReport& other);
    virtual GBAReport *dup() const {return new GBAReport(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GBAReport& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GBAReport& obj) {obj.parsimUnpack(b);}


#endif // ifndef __MPCP_M_H

